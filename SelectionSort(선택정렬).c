#include <stdio.h>

/*
선택정렬은 기본적으로 배열에서 가장 작은 수를 찾아서 하나씩 앞으로 가져오는 방식이다.
하나의 숫자를 모든 배열안의 숫자와 비교해야하기때문에 시간이 오래걸린다.
시간복잡도는 처음에는 10번, 9번, 8번,... ,1번으로 점점 줄면서 반복하기 때문에 
N * (N + 1) / 2이다. 여기서 상수의 연산은 N값이 매우 큰 경우를 가정하면 무의미하기 때문에
==>  O(N * N) 이다.
*/

int main(void) {
  int arr[10] = {1,3,10,9,8,5,6,2,4,7};
	int i, index, min, temp;
	
	for(i = 0; i < 10; i++){ //배열안의 데이터 갯수가 10개이기 때문에 10번을 반복해야한다.
		min = 9999; //우선 가장 작은 숫자를 판별하기 위해 배열안의 숫자보다 큰 숫자를 min으로 지정해준다. min은 앞에부터 하나씩 비교할 때마다 9999로 초기화 된다.
		for(int j = i; j < 10; j++){ // 배열의 앞 숫자와 나머지 숫자들을 비교해주기위해 i번째 부터 시작한다.
			if(min > arr[j]){ // 만약 배열의 j 번째 수가 min보다 작으면,
				min = arr[j]; // min을 배열의 j 번째 수로 바꿔준다.
				index = j; // 그리고 j 번째 수와 i 번째 숫자의 위치를 바꿔주기 위해 j를 index에 넣어준다.
			}
		}
		// 스와핑 방법이다.
		temp = arr[index]; // temp에 배열의 index번째 수를 저장한다. i 번째 턴의 가장 작은 수 이다.
		arr[index] = arr[i]; // 배열의 i번째 수를 index번에 저장한다. i 번째 수와 가장 작은 수를 교체해준다.
		arr[i] = temp; // temp의 수를 배열의 i 번째에 저장한다. temp에 들어있는 수가 현재 min value임으로 i 번째에 저장하면 순서가 맞춰진다.
	}

	for(i = 0; i < 10; i++){
		printf("%d ",arr[i]);
	}
  return 0;
}
